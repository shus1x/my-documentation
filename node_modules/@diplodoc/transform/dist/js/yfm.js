"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  // node_modules/get-root-node-polyfill/index.js
  var require_get_root_node_polyfill = __commonJS({
    "node_modules/get-root-node-polyfill/index.js"(exports, module) {
      "use strict";
      function getRootNode2(opt) {
        var composed = typeof opt === "object" && Boolean(opt.composed);
        return composed ? getShadowIncludingRoot(this) : getRoot(this);
      }
      function getShadowIncludingRoot(node) {
        var root = getRoot(node);
        if (isShadowRoot(root)) {
          return getShadowIncludingRoot(root.host);
        }
        return root;
      }
      function getRoot(node) {
        if (node.parentNode != null) {
          return getRoot(node.parentNode);
        }
        return node;
      }
      function isShadowRoot(node) {
        return node.nodeName === "#document-fragment" && node.constructor.name === "ShadowRoot";
      }
      if (typeof module === "object" && module.exports) {
        module.exports = getRootNode2;
      }
    }
  });

  // node_modules/@diplodoc/cut-extension/build/runtime/index.js
  (() => {
    var c = "yfm_cut", i = { CUT: ".yfm .yfm-cut", TITLE: ".yfm .yfm-cut-title", CONTENT: ".yfm .yfm-cut-content" }, C = { OPEN: "open" };
    var o = (e) => {
      let t = e.composedPath();
      return Array.isArray(t) && t.length > 0 ? t[0] : e.target;
    }, n = (e) => {
      let t = o(e);
      return !t || !t.matches;
    };
    var I = class {
      constructor(t) {
        __publicField(this, "__doc");
        __publicField(this, "_onDocClick", (t) => {
          if (n(t)) return;
          let g = this._findTitleInPath(t);
          g && this._toggleCut(g);
        });
        __publicField(this, "_matchTitle", (t) => {
          var _a;
          return t instanceof HTMLElement ? (_a = t == null ? void 0 : t.matches) == null ? void 0 : _a.call(t, i.TITLE) : false;
        });
        this.__doc = t, this.__doc.addEventListener("click", this._onDocClick);
      }
      destroy() {
        this.__doc.removeEventListener("click", this._onDocClick);
      }
      focusActiveCut() {
        let t = window.location.hash.slice(1), g = document.getElementById(t);
        g instanceof HTMLElement && g.matches(i.CUT) && (g.classList.toggle(C.OPEN), g.setAttribute("open", "true"), setTimeout(() => {
          g.classList.add("cut-highlight"), g.scrollIntoView();
        }, 70), setTimeout(() => {
          g.classList.remove("cut-highlight");
        }, 1e3));
      }
      _findTitleInPath(t) {
        var _a, _b;
        let g = o(t);
        return this._matchTitle(g) ? g : (_b = (_a = t.composedPath) == null ? void 0 : _a.call(t)) == null ? void 0 : _b.find(this._matchTitle);
      }
      _toggleCut(t) {
        var _a;
        (_a = t.parentElement) == null ? void 0 : _a.classList.toggle(C.OPEN);
      }
    };
    typeof window < "u" && typeof document < "u" && !window[c] && (window[c] = new I(document));
  })();

  // node_modules/@diplodoc/tabs-extension/build/runtime/index.js
  (() => {
    var W = "yfm-tabs", R = "yfm-tab", O = "yfm-tab-panel", L = "yfm-tab-list", r = "active";
    var T = "data-diplodoc-group", G = "data-diplodoc-key", x = "data-diplodoc-variant", v = "data-diplodoc-id", H = "defaultTabsGroup-";
    var h = "data-diplodoc-forced";
    var N = "yfm-tabs-dropdown-select";
    var U = "yfm-tabs-vertical";
    var F = Symbol.for("diplodocTabs");
    var y = (s) => {
      let t = s.composedPath();
      return Array.isArray(t) && t.length > 0 ? t[0] : s.target;
    }, Z = (s) => {
      let t = y(s);
      return !t || !t.matches;
    }, Q = (s) => Math.abs(s.scrollHeight - s.clientHeight) > 1 ? s : s.parentElement ? Q(s.parentElement) : void 0, X = (s, t) => {
      let e = s.getBoundingClientRect(), g = t.getBoundingClientRect();
      return { top: e.top - g.top, left: e.left - g.left, scrollTop: t.scrollTop, scrollLeft: t.scrollLeft };
    };
    var n = { TABS: `.${W}`, TAB_LIST: `.${L}`, TAB: `.${R}`, TAB_PANEL: `.${O}`, VERTICAL_TABS: `.${U}` }, f = class {
      constructor(t) {
        this._onSelectTabHandlers = /* @__PURE__ */ new Set();
        this._document = t, this._document.addEventListener("click", (e) => {
          let g = y(e);
          if (e.target && this.hideAllDropdown(e.target), Z(e)) return;
          if (this.isElementDropdownSelect(g)) {
            g.classList.toggle(r);
            return;
          }
          if (!this.isValidTabElement(g)) return;
          let o = this.getTabDataFromHTMLElement(g);
          o && this._selectTab(o, g);
        }), this._document.addEventListener("keydown", (e) => {
          let g = null;
          switch (e.key) {
            case "ArrowLeft": {
              g = "left";
              break;
            }
            case "ArrowRight": {
              g = "right";
              break;
            }
            case "ArrowUp": {
              g = "left";
              break;
            }
            case "ArrowDown": {
              g = "right";
              break;
            }
          }
          if (!g) return;
          let o = y(e);
          if (Z(e) || !this.isValidTabElement(o)) return;
          let { tabs: c, nodes: a } = this.getTabs(o), I = this.getTabDataFromHTMLElement(o), A = c.findIndex(({ key: C }) => (I == null ? void 0 : I.key) && C === I.key);
          if (!I || c.length <= 1 || A === -1) return;
          let i = (A + (g === "left" ? -1 : 1) + c.length) % c.length;
          this.selectTab(c[i]), a[i].focus();
        });
      }
      onSelectTab(t) {
        return this._onSelectTabHandlers.add(t), () => {
          this._onSelectTabHandlers.delete(t);
        };
      }
      selectTabById(t, e) {
        let g = this._document.querySelector(`${n.TAB}[${v}="${t}"]`);
        if (!g || !this.isValidTabElement(g)) return;
        let o = this.getTabDataFromHTMLElement(g);
        o && this._selectTab(o, g), e != null && e.scrollToElement && g.scrollIntoView();
      }
      selectTab(t) {
        this._selectTab(t);
      }
      _selectTab(t, e) {
        let { group: g, key: o, variant: c } = t;
        if (!g) return;
        let a = e && Q(e), I = a && X(e, a);
        this.updateHTML({ group: g, key: o, variant: c }, e, c) > 0 && (this.fireSelectTabEvent({ group: g, key: o, variant: c }, e == null ? void 0 : e.dataset.diplodocId), I && this.resetScroll(e, a, I));
      }
      updateHTML(t, e, g) {
        switch (g) {
          case "radio":
            return this.updateHTMLRadio(t, e);
          case "accordion":
            return this.updateHTMLAccordion(t, e);
          case "regular":
            return this.updateHTMLRegular(t);
          case "dropdown":
            return this.updateHTMLDropdown(t);
        }
        return 0;
      }
      updateHTMLRadio(t, e) {
        let { group: g, key: o } = t, { isForced: c, root: a } = this.didTabOpenForce(e), I = c ? `.yfm-vertical-tab[${h}="true"]` : "", A = this._document.querySelectorAll(`${n.TABS}[${T}="${g}"] ${n.TAB}[${G}="${o}"]${I}`);
        c && (a == null || a.removeAttribute(h));
        let i = 0;
        return A.forEach((C) => {
          let m = C.parentNode.children;
          for (let p = 0; p < m.length; p += 2) {
            let [d, b] = [m.item(p), m.item(p + 1)], u = d.children.item(0);
            if (d === C) {
              u.checked ? (d.classList.remove("active"), b == null || b.classList.remove("active"), u.removeAttribute("checked")) : (d.classList.add("active"), b == null || b.classList.add("active"), u.setAttribute("checked", "true"));
              continue;
            }
            u.hasAttribute("checked") && (d.classList.remove("active"), b == null || b.classList.remove("active"), u.removeAttribute("checked")), i++;
          }
        }), i;
      }
      updateHTMLRegular(t) {
        let { group: e, key: g } = t, o = this._document.querySelectorAll(`${n.TABS}[${T}="${e}"] ${n.TAB}[${G}="${g}"]`), c = 0;
        return o.forEach((a) => {
          let I = a;
          if (!this.isValidTabElement(I) || I.dataset.diplodocIsActive === "true") return;
          c++;
          let A = a, i = A.parentNode, C = i == null ? void 0 : i.parentNode, l = Array.from((i == null ? void 0 : i.querySelectorAll(n.TAB)) || []), m = Array.from((C == null ? void 0 : C.children) || []).filter((d) => d.classList.contains(O)), p = l.indexOf(A);
          l.forEach((d, b) => {
            let u = m[b], B = b === p, D = d;
            D.dataset.diplodocIsActive = B ? "true" : "false", d.classList.toggle(r, B), d.setAttribute("aria-selected", B.toString()), d.setAttribute("tabindex", B ? "0" : "-1"), u.classList.toggle(r, B);
          });
        }), c;
      }
      updateHTMLDropdown(t) {
        let { group: e, key: g } = t, o = this._document.querySelectorAll(`${n.TABS}[${T}="${e}"] ${n.TAB}[${G}="${g}"]`), c = 0;
        return o.forEach((a) => {
          let I = a.closest(`[${x}=dropdown]`);
          if (!(I != null && I.children)) return;
          let A = I.children.item(0), i = I.children.item(1);
          A == null || A.classList.remove(r);
          let C = Array.from((i == null ? void 0 : i.children) || []).indexOf(a) + 2;
          for (let l = 2; l < I.children.length; l++) {
            let m = I.children.item(l), p = i == null ? void 0 : i.children.item(l - 2);
            if (c++, C === l) {
              m == null || m.classList.add(r), p.classList.add(r), A.innerHTML = a.innerHTML, A.classList.add("filled");
              continue;
            }
            p.classList.remove(r), m.classList.remove(r);
          }
        }), c;
      }
      updateHTMLAccordion(t, e) {
        let { group: g, key: o } = t, c = this._document.querySelectorAll(`${n.TABS}[${T}="${g}"] ${n.TAB}[${G}="${o}"]`), a = 0;
        return c.forEach((I) => {
          let A = I.closest(`[${x}=accordion]`);
          if (A != null && A.children) for (let i = 0; i < A.children.length; i += 2) {
            let C = A.children.item(i), l = A.children.item(i + 1);
            if (a++, I === C) {
              C == null || C.classList.toggle(r), l == null || l.classList.toggle(r);
              continue;
            }
            C == null || C.classList.remove(r), l == null || l.classList.remove(r);
          }
        }), e && !this.checkVisible(e) && setTimeout(() => {
          e.scrollIntoView({ block: "nearest" });
        }), a;
      }
      checkVisible(t) {
        let e = t.getBoundingClientRect(), g = Math.max(document.documentElement.clientHeight, window.innerHeight);
        return !(e.bottom < 0 || e.top - g >= 0);
      }
      hideAllDropdown(t) {
        this._document.querySelectorAll(".yfm-tabs-dropdown-select.active").forEach((g) => {
          g.contains(t) || g.classList.remove(r);
        });
      }
      resetScroll(t, e, g) {
        let o = X(t, e), c = o.top - g.top, a = o.left - g.left, I = o.scrollTop - g.scrollTop, A = o.scrollLeft - g.scrollLeft;
        e.scrollTo(e.scrollLeft + a - A, e.scrollTop + c - I);
      }
      didTabOpenForce(t) {
        if (!t) return {};
        if (t.dataset.diplodocForced) return { root: t, isForced: true };
        let e = t.dataset.diplodocVerticalTab ? t : t.parentElement, g = typeof (e == null ? void 0 : e.dataset.diplodocForced) != "undefined";
        return { root: e, isForced: g };
      }
      fireSelectTabEvent(t, e) {
        let { group: g, key: o, variant: c } = t, a = g.startsWith(H) ? { key: o, variant: c } : t;
        this._onSelectTabHandlers.forEach((I) => {
          I({ tab: a, currentTabId: e });
        });
      }
      getTabsType(t) {
        let e = t.closest(`[${x}]`);
        if (e) return e.dataset.diplodocVariant;
      }
      isValidTabElement(t) {
        return !!this.getTabsType(t);
      }
      isElementDropdownSelect(t) {
        return t.classList.contains(N);
      }
      getTabDataFromHTMLElement(t) {
        var c, a, I;
        let e = this.getTabsType(t);
        if (e === "radio") {
          let A = t.dataset.diplodocVerticalTab ? t : t.parentElement, i = A.dataset.diplodocKey, C = (c = A.closest(n.TABS)) == null ? void 0 : c.dataset.diplodocGroup;
          return i && C ? { group: C, key: i, variant: "radio" } : null;
        }
        if (e === "dropdown" || e === "accordion") {
          let A = t.dataset.diplodocKey, i = (a = t.closest(n.TABS)) == null ? void 0 : a.dataset.diplodocGroup;
          return A && i ? { group: i, key: A, variant: e } : null;
        }
        let g = t.dataset.diplodocKey, o = (I = t.closest(n.TABS)) == null ? void 0 : I.dataset.diplodocGroup;
        return g && o ? { group: o, key: g, variant: "regular" } : null;
      }
      getTabs(t) {
        var c, a;
        let e = (c = t.closest(n.TABS)) == null ? void 0 : c.dataset.diplodocGroup, g = (a = t.closest(n.TAB_LIST)) == null ? void 0 : a.querySelectorAll(n.TAB), o = [];
        return g.forEach((I) => {
          let A = I == null ? void 0 : I.dataset.diplodocKey;
          A && o.push({ group: e, key: A, variant: "regular" });
        }), { tabs: o, nodes: g };
      }
    };
    typeof window != "undefined" && typeof document != "undefined" && !window[F] && (window[F] = new f(document));
  })();

  // src/js/polyfill.js
  var import_get_root_node_polyfill = __toESM(require_get_root_node_polyfill());
  if (typeof document !== "undefined") {
    (function(e) {
      const matches = e.matches || e.matchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector || e.oMatchesSelector;
      if (matches) {
        e.matches = e.matchesSelector = matches;
      } else {
        e.matches = e.matchesSelector = function matches2(selector) {
          const rootNode = e.getRootNode ? e.getRootNode() : import_get_root_node_polyfill.default.call(e);
          const matches3 = rootNode.querySelectorAll(selector);
          const th = this;
          return Array.prototype.some.call(matches3, (e2) => {
            return e2 === th;
          });
        };
      }
    })(Element.prototype);
  }

  // src/js/utils.ts
  var getEventTarget = (event) => {
    const path = event.composedPath();
    return Array.isArray(path) && path.length > 0 ? path[0] : event.target;
  };
  var isCustom = (event) => {
    const target = getEventTarget(event);
    return !target || !target.matches;
  };

  // src/js/code.ts
  var BUTTON_SELECTOR = ".yfm-clipboard-button";
  function copyToClipboard(text) {
    if (!text) {
      return Promise.resolve();
    }
    if (navigator.clipboard && typeof navigator.clipboard.writeText) {
      return navigator.clipboard.writeText(text);
    }
    const textarea = document.createElement("textarea");
    textarea.setAttribute("style", "position: absolute; left: 1000%");
    textarea.textContent = text;
    document.body.append(textarea);
    textarea.select();
    document.execCommand("copy");
    document.body.removeChild(textarea);
    return Promise.resolve();
  }
  function notifySuccess(svgButton) {
    if (!svgButton) {
      return;
    }
    const id = svgButton.getAttribute("data-animation");
    const icon = svgButton.getRootNode().getElementById(`visibileAnimation-${id}`);
    if (!icon) {
      return;
    }
    icon.beginElement();
  }
  if (typeof document !== "undefined") {
    document.addEventListener("click", (event) => {
      const target = getEventTarget(event);
      if (isCustom(event) || !target.matches(BUTTON_SELECTOR)) {
        return;
      }
      const parent = target.parentNode;
      if (!parent) {
        return;
      }
      const code = parent.querySelector("pre code");
      if (!code) {
        return;
      }
      copyToClipboard(code.innerText).then(() => {
        notifySuccess(parent.querySelector(".yfm-clipboard-icon"));
      });
    });
  }

  // src/js/term/utils.ts
  var Selector = {
    TITLE: ".yfm .yfm-term_title",
    CONTENT: ".yfm .yfm-term_dfn"
  };
  var openClass = "open";
  var openDefinitionClass = Selector.CONTENT.replace(/\./g, "") + " " + openClass;
  var isListenerNeeded = true;
  function createDefinitionElement(termElement) {
    var _a;
    const termKey = termElement.getAttribute("term-key");
    const definitionTemplate = document.getElementById(
      `${termKey}_template`
    );
    const definitionElement = definitionTemplate == null ? void 0 : definitionTemplate.content.cloneNode(true).firstChild;
    (_a = definitionTemplate == null ? void 0 : definitionTemplate.parentElement) == null ? void 0 : _a.appendChild(definitionElement);
    definitionTemplate.remove();
    return definitionElement;
  }
  function setDefinitionId(definitionElement, termElement) {
    const termId = termElement.getAttribute("id") || Math.random().toString(36).substr(2, 8);
    definitionElement == null ? void 0 : definitionElement.setAttribute("term-id", termId);
  }
  function setDefinitonAriaAttributes(definitionElement, termElement) {
    const ariaLive = termElement.getAttribute("aria-live") || "polite";
    definitionElement == null ? void 0 : definitionElement.setAttribute("aria-live", ariaLive);
    definitionElement == null ? void 0 : definitionElement.setAttribute("aria-modal", "true");
  }
  function setDefinitionPosition(definitionElement, termElement) {
    const {
      x: termX,
      y: termY,
      right: termRight,
      left: termLeft,
      width: termWidth,
      height: termHeight
    } = termElement.getBoundingClientRect();
    const termParent = termParentElement(termElement);
    if (!termParent) {
      return;
    }
    const { right: termParentRight, left: termParentLeft } = termParent.getBoundingClientRect();
    if ((termParentRight < termLeft || termParentLeft > termRight) && !isListenerNeeded) {
      closeDefinition(definitionElement);
      return;
    }
    if (isListenerNeeded && termParent) {
      termParent.addEventListener("scroll", termOnResize);
      isListenerNeeded = false;
    }
    const relativeX = Number(definitionElement.getAttribute("relativeX"));
    const relativeY = Number(definitionElement.getAttribute("relativeY"));
    if (relativeX === termX && relativeY === termY) {
      return;
    }
    definitionElement.setAttribute("relativeX", String(termX));
    definitionElement.setAttribute("relativeY", String(termY));
    const offsetTop = termHeight + 5;
    const definitionParent = definitionElement.parentElement;
    if (!definitionParent) {
      return;
    }
    const { width: definitionWidth } = definitionElement.getBoundingClientRect();
    const { left: definitionParentLeft } = definitionParent.getBoundingClientRect();
    const definitionLeftCoordinate = Number(getCoords(termElement).left);
    const definitionRightCoordinate = definitionWidth + definitionLeftCoordinate;
    const definitionOutOfScreenOnLeft = definitionLeftCoordinate - definitionWidth < 0;
    const definitionOutOfScreenOnRight = definitionRightCoordinate > document.body.clientWidth;
    const isAlignSwapped = definitionOutOfScreenOnRight || document.dir === "rtl";
    const fitDefinitionDocument = isAlignSwapped && !definitionOutOfScreenOnLeft ? definitionWidth - termWidth : 0;
    const customHeaderTop = getCoords(definitionParent).top - definitionParent.offsetTop;
    const offsetRight = 5;
    const shiftLeft = definitionOutOfScreenOnRight ? definitionRightCoordinate - document.body.clientWidth + offsetRight : 0;
    const offsetLeft = getCoords(termElement).left - definitionParentLeft + definitionParent.offsetLeft - fitDefinitionDocument;
    const isShiftLeftNeeded = offsetLeft + definitionWidth >= document.body.clientWidth;
    definitionElement.style.top = Number(getCoords(termElement).top + offsetTop - customHeaderTop) + "px";
    definitionElement.style.left = Number(offsetLeft - (isShiftLeftNeeded ? shiftLeft : 0)) + "px";
  }
  function termOnResize() {
    const openedDefinition = document.getElementsByClassName(openDefinitionClass)[0];
    if (!openedDefinition) {
      return;
    }
    const termId = openedDefinition.getAttribute("term-id") || "";
    const termElement = document.getElementById(termId);
    if (!termElement) {
      return;
    }
    setDefinitionPosition(openedDefinition, termElement);
  }
  function termParentElement(term) {
    if (!term) {
      return null;
    }
    const closestScrollableParent = term.closest("table") || term.closest("code");
    return closestScrollableParent || term.parentElement;
  }
  function openDefinition(target) {
    const openedDefinition = document.getElementsByClassName(openDefinitionClass)[0];
    const termId = target.getAttribute("id");
    const termKey = target.getAttribute("term-key");
    let definitionElement = document.getElementById(termKey + "_element");
    if (termKey && !definitionElement) {
      definitionElement = createDefinitionElement(target);
    }
    const isSameTerm = openedDefinition && termId === openedDefinition.getAttribute("term-id");
    if (isSameTerm) {
      closeDefinition(openedDefinition);
      return;
    }
    const isTargetDefinitionContent = target.closest(
      [Selector.CONTENT.replace(" ", ""), openClass].join(".")
    );
    if (openedDefinition && !isTargetDefinitionContent) {
      closeDefinition(openedDefinition);
    }
    if (!target.matches(Selector.TITLE) || !definitionElement) {
      return;
    }
    setDefinitionId(definitionElement, target);
    setDefinitonAriaAttributes(definitionElement, target);
    setDefinitionPosition(definitionElement, target);
    definitionElement.classList.toggle(openClass);
    trapFocus(definitionElement);
  }
  function closeDefinition(definition) {
    definition.classList.remove(openClass);
    const termId = definition.getAttribute("term-id") || "";
    const term = document.getElementById(termId);
    const termParent = termParentElement(term);
    if (!termParent) {
      return;
    }
    termParent.removeEventListener("scroll", termOnResize);
    term == null ? void 0 : term.focus();
    isListenerNeeded = true;
  }
  function getCoords(elem) {
    const box = elem.getBoundingClientRect();
    const body = document.body;
    const docEl = document.documentElement;
    const scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
    const scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;
    const clientTop = docEl.clientTop || body.clientTop || 0;
    const clientLeft = docEl.clientLeft || body.clientLeft || 0;
    const top = box.top + scrollTop - clientTop;
    const left = box.left + scrollLeft - clientLeft;
    return { top: Math.round(top), left: Math.round(left) };
  }
  function trapFocus(element) {
    const focusableElements = element.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    const firstFocusableElement = focusableElements[0];
    const lastFocusableElement = focusableElements[focusableElements.length - 1];
    if (firstFocusableElement) {
      firstFocusableElement.focus();
    }
    element.addEventListener("keydown", function(e) {
      const isTabPressed = e.key === "Tab" || e.keyCode === 9;
      if (!isTabPressed) {
        return;
      }
      if (e.shiftKey) {
        if (document.activeElement === firstFocusableElement) {
          lastFocusableElement.focus();
          e.preventDefault();
        }
      } else if (document.activeElement === lastFocusableElement) {
        firstFocusableElement.focus();
        e.preventDefault();
      }
    });
  }

  // src/js/term/index.ts
  if (typeof document !== "undefined") {
    document.addEventListener("click", (event) => {
      if (getEventTarget(event) || !isCustom(event)) {
        openDefinition(getEventTarget(event));
      }
    });
    document.addEventListener("keydown", (event) => {
      const openedDefinition = document.getElementsByClassName(
        openDefinitionClass
      )[0];
      if (event.key === "Enter" && document.activeElement) {
        openDefinition(document.activeElement);
      }
      if (event.key === "Escape" && openedDefinition) {
        closeDefinition(openedDefinition);
      }
    });
    window.addEventListener("resize", () => {
      const openedDefinition = document.getElementsByClassName(
        openDefinitionClass
      )[0];
      if (!openedDefinition) {
        return;
      }
      const termId = openedDefinition.getAttribute("term-id") || "";
      const termElement = document.getElementById(termId);
      if (!termElement) {
        openedDefinition.classList.toggle(openClass);
        return;
      }
      setDefinitionPosition(openedDefinition, termElement);
    });
  }

  // src/js/wide-mode/constants.ts
  var WIDE_ELEMENTS_SELECTOR = "[wide-content]";

  // src/js/wide-mode/icons/expand.ts
  var expand_default = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 16 16"><path fill="currentColor" fill-rule="evenodd" d="M7.754 2.004a.75.75 0 0 0 0 1.5h4.75v4.742a.75.75 0 0 0 1.5 0V2.754a.75.75 0 0 0-.75-.75zm.492 11.992a.75.75 0 0 0 0-1.5h-4.75V7.754a.75.75 0 0 0-1.5 0v5.492a.75.75 0 0 0 .75.75z" clip-rule="evenodd"/></svg>`;

  // src/js/wide-mode/icons/close.ts
  var close_default = `<svg width="28" height="28" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg" class="close-action"><path fillRule="evenodd" clipRule="evenodd" d="M9.46967 9.46967C9.76256 9.17678 10.2374 9.17678 10.5303 9.46967L14 12.9393L17.4697 9.46967C17.7626 9.17678 18.2374 9.17678 18.5303 9.46967C18.8232 9.76256 18.8232 10.2374 18.5303 10.5303L15.0607 14L18.5303 17.4697C18.8232 17.7626 18.8232 18.2374 18.5303 18.5303C18.2374 18.8232 17.7626 18.8232 17.4697 18.5303L14 15.0607L10.5303 18.5303C10.2374 18.8232 9.76256 18.8232 9.46967 18.5303C9.17678 18.2374 9.17678 17.7626 9.46967 17.4697L12.9393 14L9.46967 10.5303C9.17678 10.2374 9.17678 9.76256 9.46967 9.46967Z" fill="var(--g-color-text-primary)" fillOpacity="0.85"/></svg>`;

  // src/js/wide-mode/modal.ts
  var remove = () => {
    if (!window.wideTemplate) {
      return;
    }
    window.wideTemplate.style.display = "none";
    window.wideTemplate.content(void 0);
  };
  var tbodyOf = (node) => {
    if (node.tagName !== "TABLE") {
      return void 0;
    }
    const elements = Array.from(node.children);
    const thead = elements.find((child) => child.tagName === "THEAD");
    if (thead) {
      return void 0;
    }
    const tbody = elements.find((child) => child.tagName === "TBODY");
    return tbody;
  };
  var container = () => {
    if (window.wideTemplate) {
      return window.wideTemplate;
    }
    const template = document.createElement("div");
    template.classList.add("dc-doc-page", "wide-container");
    const overlay = document.createElement("div");
    overlay.classList.add("wide-content-overlay");
    overlay.addEventListener("click", remove);
    const wrapper = document.createElement("div");
    wrapper.classList.add("yfm", "wide-content-wrapper");
    const toolbar = document.createElement("div");
    toolbar.classList.add("wide-toolbar");
    const close = document.createElement("div");
    close.classList.add("wide-actions");
    close.addEventListener("click", remove);
    close.innerHTML = close_default;
    const title = document.createElement("p");
    title.classList.add("wide-entity-name");
    template.label = (content2) => {
      title.innerHTML = content2 || "";
    };
    const content = document.createElement("div");
    content.classList.add("wide-content");
    template.content = (target) => {
      var _a;
      if (typeof target === "undefined") {
        content.innerHTML = "";
        return;
      }
      const cloned = target.cloneNode(true);
      const tbody = tbodyOf(cloned);
      (_a = tbody == null ? void 0 : tbody.classList) == null ? void 0 : _a.add("wide-thead-content");
      content.replaceChildren(cloned);
    };
    toolbar.append(title, close);
    wrapper.append(toolbar, content);
    template.append(overlay, wrapper);
    template.style.display = "none";
    document.body.appendChild(template);
    window.wideTemplate = template;
    return template;
  };
  var render = (content) => {
    const template = container();
    template.label(content.title);
    template.content(content);
    template.style.display = "flex";
  };
  var modal = {
    render,
    remove
  };

  // src/js/wide-mode/apply.ts
  var wrap = (target) => {
    var _a;
    if ((_a = target.parentElement) == null ? void 0 : _a.classList.contains("wide-element-wrapper")) {
      return;
    }
    target.classList.add("wide-inner-element");
    const handler = document.createElement("div");
    handler.innerHTML = expand_default;
    handler.classList.add("wide-content-viewer");
    handler.addEventListener("click", () => modal.render(target));
    const container2 = document.createElement("div");
    container2.classList.add("wide-element-wrapper");
    target.before(container2);
    container2.appendChild(target);
    container2.appendChild(handler);
  };
  var applyWideMode = () => {
    const allWideElements = Array.from(
      document.querySelectorAll(WIDE_ELEMENTS_SELECTOR)
    );
    allWideElements.forEach(wrap);
  };

  // src/js/wide-mode/index.ts
  if (typeof window !== "undefined" && typeof document !== "undefined") {
    window.addEventListener("load", applyWideMode);
  }

  // src/js/patch.ts
  var patch = () => {
    applyWideMode();
  };
  if (typeof window !== "undefined") {
    window.patchAfterRender = patch;
  }
})();
//# sourceMappingURL=yfm.js.map
