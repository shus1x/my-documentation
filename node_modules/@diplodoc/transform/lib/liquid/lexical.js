"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseLiteral = exports.isSingleVariable = exports.isVariable = exports.isLiteral = exports.getParsedMethod = exports.isSupportedMethod = exports.operators = exports.rangeLine = exports.tagLine = exports.variable = exports.singleVariable = exports.vars = exports.quoteBalanced = void 0;
// quote related
const singleQuoted = /'[^']*'/;
const doubleQuoted = /"[^"]*"/;
const quoted = new RegExp(`${singleQuoted.source}|${doubleQuoted.source}`);
exports.quoteBalanced = new RegExp(`(?:${quoted.source}|[^'"])*`);
exports.vars = /((not_var)?({{2}([. \w-|(),]+)}{2}))/gm;
exports.singleVariable = /^{{2}([. \w-|(),]+)}{2}$/;
// basic types
const number = /-?\d+\.?\d*|\.?\d+/;
const bool = /true|false/;
// property access
const identifier = /[\w-|]+[?]?/;
const subscript = new RegExp(`\\[(?:${quoted.source}|[\\w-\\.]+)\\]`);
const literal = new RegExp(`(?:${quoted.source}|${bool.source}|${number.source})`);
exports.variable = new RegExp(`${identifier.source}(?:\\.${identifier.source}|${subscript.source})*`);
// range related
const rangeLimit = new RegExp(`(?:${exports.variable.source}|${number.source})`);
const rangeCapture = new RegExp(`\\((${rangeLimit.source})\\.\\.(${rangeLimit.source})\\)`);
// full match
exports.tagLine = new RegExp(`^\\s*(${identifier.source})\\s*([\\s\\S]*)\\s*$`);
const literalLine = new RegExp(`^${literal.source}$`, 'i');
const variableLine = new RegExp(`^${exports.variable.source}$`);
const numberLine = new RegExp(`^${number.source}$`);
const boolLine = new RegExp(`^${bool.source}$`, 'i');
const quotedLine = new RegExp(`^${quoted.source}$`);
exports.rangeLine = new RegExp(`^${rangeCapture.source}$`);
exports.operators = [
    /\s+or\s+/,
    /\s+and\s+/,
    /[=]=|!=|<=|>=|<|>|\s+contains\s+/,
    /\s+\|\s+/,
    /\s+\|/,
    /\|\s+/,
    /\./,
];
const prepareArgsForMethods = {
    slice: (args) => args.map((arg) => Number(arg)),
};
const supportedMethods = Object.keys(prepareArgsForMethods);
const supportedMethodsRE = new RegExp(`^(${supportedMethods.join('\\|')})\\(([^)]*)\\)$`);
const isSupportedMethod = (exp) => {
    return supportedMethodsRE.test(exp);
};
exports.isSupportedMethod = isSupportedMethod;
const getParsedMethod = (exp) => {
    const match = exp.match(supportedMethodsRE);
    if (!match)
        return null;
    const name = match[1];
    const args = match[2].split(/[\s,]+/);
    return {
        name,
        args,
    };
};
exports.getParsedMethod = getParsedMethod;
const isLiteral = (str) => literalLine.test(str);
exports.isLiteral = isLiteral;
const isVariable = (str) => variableLine.test(str);
exports.isVariable = isVariable;
const isSingleVariable = (str) => exports.singleVariable.test(str);
exports.isSingleVariable = isSingleVariable;
function parseLiteral(str) {
    let res = str.match(numberLine);
    if (res) {
        return Number(str);
    }
    res = str.match(boolLine);
    if (res) {
        return str.toLowerCase() === 'true';
    }
    res = str.match(quotedLine);
    if (res) {
        return str.slice(1, -1);
    }
    throw new TypeError(`cannot parse '${str}' as literal`);
}
exports.parseLiteral = parseLiteral;
//# sourceMappingURL=lexical.js.map