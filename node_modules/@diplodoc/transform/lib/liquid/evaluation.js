"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.evalExp = exports.NoValue = void 0;
const getObject_1 = __importDefault(require("../getObject"));
const log_1 = require("../log");
const lexical = __importStar(require("./lexical"));
const filters_1 = __importDefault(require("./filters"));
const errors_1 = require("./errors");
const operators = {
    '==': ((l, r) => l === r),
    '!=': ((l, r) => l !== r),
    '>': ((l, r) => l !== null && r !== null && l > r),
    '<': ((l, r) => l !== null && r !== null && l < r),
    '>=': ((l, r) => l !== null && r !== null && l >= r),
    '<=': ((l, r) => l !== null && r !== null && l <= r),
    contains: ((l, r) => l !== null && r !== null && l.includes(r)),
    and: ((l, r) => isTruthy(l) && isTruthy(r)),
    or: ((l, r) => isTruthy(l) || isTruthy(r)),
    '|': ((l, filter, exp) => {
        try {
            return filter(l);
        }
        catch (e) {
            if (!filter) {
                throw new errors_1.SkippedEvalError('Cannot apply an unsupported filter', exp);
            }
            throw new errors_1.SkippedEvalError('There are some problems with the filter', exp);
        }
    }),
    '.': ((l, r, exp) => {
        const parsed = lexical.getParsedMethod(r);
        try {
            if (!parsed) {
                throw new Error();
            }
            const { name, args } = parsed;
            return l[name](...args);
        }
        catch (e) {
            if (!l) {
                throw new errors_1.SkippedEvalError(`Cannot apply the function '${name}' on an undefined variable`, exp);
            }
            throw new errors_1.SkippedEvalError('There are some problems with the function', exp);
        }
    }),
};
exports.NoValue = Symbol('NoValue');
function evalValue(originStr, scope, strict) {
    const str = originStr && originStr.trim();
    if (!str) {
        return undefined;
    }
    if (lexical.isLiteral(str)) {
        return lexical.parseLiteral(str);
    }
    if (lexical.isVariable(str)) {
        return (0, getObject_1.default)(str, scope, strict ? exports.NoValue : undefined);
    }
    throw new TypeError(`cannot eval '${str}' as value`);
}
function isTruthy(val) {
    return !isFalsy(val);
}
function isFalsy(val) {
    return val === false || undefined === val || val === null;
}
const operatorREs = lexical.operators.map((op) => new RegExp(`^(${lexical.quoteBalanced.source})(${op.source})(${lexical.quoteBalanced.source})$`));
function evalExp(exp, scope, strict = false) {
    if (Object.getOwnPropertyNames(filters_1.default).includes(exp.trim())) {
        return filters_1.default[exp.trim()];
    }
    if (lexical.isSupportedMethod(exp)) {
        return exp;
    }
    try {
        for (let i = 0; i < operatorREs.length; i++) {
            const operatorRE = operatorREs[i];
            const match = exp.match(operatorRE);
            if (match) {
                const operator = match[2].trim();
                if (operator === '.' && !lexical.isSupportedMethod(match[3].trim())) {
                    break;
                }
                const op = operators[operator];
                const l = evalExp(match[1], scope, strict);
                const r = evalExp(match[3], scope, strict);
                if (l === exports.NoValue || r === exports.NoValue) {
                    return exports.NoValue;
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                return op(l, r, exp);
            }
        }
        const match = exp.match(lexical.rangeLine);
        if (match) {
            const low = Number(evalValue(match[1], scope, strict));
            const high = Number(evalValue(match[2], scope, strict));
            const range = [];
            for (let j = low; j <= high; j++) {
                range.push(j);
            }
            return range;
        }
        return evalValue(exp, scope, strict);
    }
    catch (e) {
        if (e instanceof errors_1.SkippedEvalError) {
            log_1.log.warn(`Skip error: ${e}`);
            return undefined;
        }
        log_1.log.error(`Error: ${e}`);
    }
    return undefined;
}
exports.evalExp = evalExp;
exports.default = (exp, scope, strict = false) => Boolean(evalExp(exp, scope, strict));
//# sourceMappingURL=evaluation.js.map