"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const markdown_it_1 = __importDefault(require("markdown-it"));
const markdown_it_attrs_1 = __importDefault(require("markdown-it-attrs"));
const plugins_1 = __importDefault(require("./plugins"));
const preprocessors_1 = __importDefault(require("./preprocessors"));
const log_1 = require("./log");
const highlight_1 = __importDefault(require("./highlight"));
const title_1 = __importDefault(require("./title"));
const headings_1 = __importDefault(require("./headings"));
const sanitize_1 = __importDefault(require("./sanitize"));
function initMarkdownit(options) {
    const { allowHTML = false, linkify = false, breaks = true, highlightLangs = {}, disableRules = [], } = options;
    const highlight = (0, highlight_1.default)(highlightLangs);
    const md = new markdown_it_1.default({ html: allowHTML, linkify, highlight, breaks });
    if (disableRules === null || disableRules === void 0 ? void 0 : disableRules.length) {
        md.disable(disableRules);
    }
    const env = {
        // TODO: move md.meta directly to env
        get meta() {
            return md.meta;
        },
        set meta(value) {
            md.meta = value;
        },
        // TODO: move md.assets directly to env
        get assets() {
            return md.assets;
        },
        set assets(value) {
            md.assets = value;
        },
        headings: [],
        title: '',
    };
    // Plugin options is the plugin context that remains during the build of one file
    const pluginOptions = getPluginOptions(options);
    // Init the plugins. Which install the md rules (core, block, ...)
    initPlugins(md, options, pluginOptions);
    // Init preprocessor and MD parser
    const parse = initParser(md, options, env, pluginOptions);
    // Init render to HTML compiler
    const compile = initCompiler(md, options, env);
    return { parse, compile, env };
}
function getPluginOptions(options) {
    const { vars = {}, path, extractTitle, conditionsInCode = false, disableLiquid = false } = options, customOptions = __rest(options, ["vars", "path", "extractTitle", "conditionsInCode", "disableLiquid"]);
    return Object.assign(Object.assign({}, customOptions), { conditionsInCode,
        vars,
        path,
        extractTitle,
        disableLiquid,
        log: log_1.log });
}
function initPlugins(md, options, pluginOptions) {
    const { linkify = false, linkifyTlds, leftDelimiter = '{', rightDelimiter = '}', plugins = plugins_1.default, } = options;
    // Need for ids of headers
    md.use(markdown_it_attrs_1.default, { leftDelimiter, rightDelimiter });
    plugins.forEach((plugin) => md.use(plugin, pluginOptions));
    if (linkify && linkifyTlds) {
        md.linkify.tlds(linkifyTlds, true);
    }
}
function initParser(md, options, env, pluginOptions) {
    return (input) => {
        const { extractTitle: extractTitleOption, needTitle, needFlatListHeadings = false, getPublicPath, preprocessors = preprocessors_1.default, } = options;
        // Run input preprocessor
        for (const preprocessor of preprocessors) {
            input = preprocessor(input, pluginOptions, md);
        }
        // Generate global href link
        const href = getPublicPath ? getPublicPath(options) : '';
        // Generate MD tokens
        let tokens = md.parse(input, env);
        if (extractTitleOption) {
            const { title, tokens: slicedTokens, titleTokens } = (0, title_1.default)(tokens);
            tokens = slicedTokens;
            // title tokens include other tokens that need to be transformed
            if (titleTokens.length > 1) {
                env.title = md.renderer.render(titleTokens, md.options, env);
            }
            else {
                env.title = title;
            }
        }
        if (needTitle) {
            env.title = (0, title_1.default)(tokens).title;
        }
        env.headings = (0, headings_1.default)(tokens, needFlatListHeadings, href);
        return tokens;
    };
}
function initCompiler(md, options, env) {
    const { needToSanitizeHtml = true, renderInline = false, sanitizeOptions } = options;
    return (tokens) => {
        // Remove inline tokens if inline mode is activated
        if (renderInline) {
            tokens = tokens.filter((token) => token.type === 'inline');
        }
        // Generate HTML
        const html = md.renderer.render(tokens, md.options, env);
        // Sanitize the page
        return needToSanitizeHtml ? (0, sanitize_1.default)(html, sanitizeOptions) : html;
    };
}
module.exports = initMarkdownit;
//# sourceMappingURL=md.js.map