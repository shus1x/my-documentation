"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRelativePath = exports.getPublicPath = exports.getSinglePageAnchorId = exports.getFullIncludePath = exports.getFileTokens = exports.resolveRelativePath = exports.isFileExists = void 0;
const fs_1 = require("fs");
const escapeRegExp_1 = __importDefault(require("lodash/escapeRegExp"));
const path_1 = require("path");
const liquid_1 = __importDefault(require("./liquid"));
const utils_1 = require("./utils");
const filesCache = {};
function isFileExists(file) {
    try {
        const stats = (0, fs_1.statSync)(file);
        return stats.isFile();
    }
    catch (e) {
        return false;
    }
}
exports.isFileExists = isFileExists;
function resolveRelativePath(fromPath, relativePath) {
    const { dir: fromDir } = (0, path_1.parse)(fromPath);
    return (0, path_1.resolve)(fromDir, relativePath);
}
exports.resolveRelativePath = resolveRelativePath;
function getFileTokens(path, state, options) {
    const { getVarsPerFile, vars, disableLiquid, disableLint, lintMarkdown, disableTitleRefSubstitution, disableCircularError, inheritVars = true, conditionsInCode, } = options;
    let { content } = options;
    const builtVars = (getVarsPerFile && !inheritVars ? getVarsPerFile(path) : vars) || {};
    // Read the content only if we dont have one in the args
    if (!content) {
        if (filesCache[path]) {
            content = filesCache[path];
        }
        else {
            content = (0, fs_1.readFileSync)(path, 'utf8');
            filesCache[path] = content;
        }
    }
    let sourceMap;
    if (!disableLiquid) {
        const liquidResult = (0, liquid_1.default)(content, builtVars, path, {
            withSourceMap: true,
            conditionsInCode,
        });
        content = liquidResult.output;
        sourceMap = liquidResult.sourceMap;
    }
    if (!disableLint && lintMarkdown) {
        lintMarkdown({
            input: content,
            path,
            sourceMap,
        });
    }
    const meta = state.md.meta;
    const tokens = state.md.parse(content, Object.assign(Object.assign({}, state.env), { path,
        disableTitleRefSubstitution,
        disableCircularError }));
    state.md.meta = meta;
    return tokens;
}
exports.getFileTokens = getFileTokens;
const getFullIncludePath = (includePath, root, path) => {
    let fullIncludePath;
    if (includePath.startsWith(path_1.sep)) {
        fullIncludePath = (0, path_1.join)(root, includePath);
    }
    else {
        fullIncludePath = resolveRelativePath(path, includePath);
    }
    return fullIncludePath;
};
exports.getFullIncludePath = getFullIncludePath;
function getSinglePageAnchorId(args) {
    const { root, currentPath, pathname, hash } = args;
    let resultAnchor = currentPath;
    if (pathname) {
        resultAnchor = resolveRelativePath(currentPath, pathname);
    }
    resultAnchor = resultAnchor
        .replace(root, '')
        .replace(/\.(md|ya?ml|html)$/i, '')
        .replace(new RegExp((0, escapeRegExp_1.default)(path_1.sep), 'gi'), '_');
    if (hash) {
        resultAnchor = resultAnchor + '_' + hash.slice(1);
    }
    return `#${resultAnchor}`;
}
exports.getSinglePageAnchorId = getSinglePageAnchorId;
function getPublicPath({ path, root, rootPublicPath, transformLink, }, input) {
    const currentPath = input || path || '';
    const filePath = (0, path_1.relative)((0, path_1.resolve)(root || '', rootPublicPath || ''), currentPath);
    const transformer = transformLink || utils_1.defaultTransformLink;
    const href = transformer(filePath);
    return href;
}
exports.getPublicPath = getPublicPath;
function getRelativePath(path, toPath) {
    const pathDirs = path.split(path_1.sep);
    pathDirs.pop();
    const parentPath = pathDirs.join(path_1.sep);
    return (0, path_1.relative)(parentPath, toPath);
}
exports.getRelativePath = getRelativePath;
//# sourceMappingURL=utilsFS.js.map