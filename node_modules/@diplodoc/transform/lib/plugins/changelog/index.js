"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const chalk_1 = require("chalk");
const js_yaml_1 = __importDefault(require("js-yaml"));
const CHANGELOG_OPEN_RE = /^\{% changelog %}/;
const CHANGELOG_CLOSE_RE = /^\{% endchangelog %}/;
function isOpenToken(tokens, i) {
    return (tokens[i].type === 'paragraph_open' &&
        tokens[i + 1].type === 'inline' &&
        tokens[i + 2].type === 'paragraph_close' &&
        CHANGELOG_OPEN_RE.test(tokens[i + 1].content));
}
function isCloseToken(tokens, i) {
    var _a;
    return (((_a = tokens[i]) === null || _a === void 0 ? void 0 : _a.type) === 'paragraph_open' &&
        tokens[i + 1].type === 'inline' &&
        tokens[i + 2].type === 'paragraph_close' &&
        CHANGELOG_CLOSE_RE.test(tokens[i + 1].content));
}
function isTitle(tokens, i = 0) {
    return (tokens[i].type === 'heading_open' &&
        tokens[i + 1].type === 'inline' &&
        tokens[i + 2].type === 'heading_close');
}
function isImageParagraph(tokens, i = 0) {
    var _a;
    return (tokens[i].type === 'paragraph_open' &&
        tokens[i + 1].type === 'inline' &&
        tokens[i + 2].type === 'paragraph_close' &&
        ((_a = tokens[i + 1].children) === null || _a === void 0 ? void 0 : _a.some((t) => t.type === 'image')));
}
function parseBody(tokens, state) {
    var _a, _b;
    const { md, env } = state;
    const metadataToken = tokens.shift();
    if ((metadataToken === null || metadataToken === void 0 ? void 0 : metadataToken.type) !== 'fence') {
        throw new Error('Metadata tag not found');
    }
    let metadata = {};
    const rawMetadata = js_yaml_1.default.load(metadataToken.content, {
        schema: js_yaml_1.default.JSON_SCHEMA,
    });
    if (rawMetadata && typeof rawMetadata === 'object') {
        metadata = rawMetadata;
    }
    if (!isTitle(tokens)) {
        throw new Error('Title tag not found');
    }
    const title = tokens.splice(0, 3)[1].content;
    let image;
    if (isImageParagraph(tokens)) {
        const paragraphTokens = tokens.splice(0, 3);
        const imageToken = (_b = (_a = paragraphTokens[1]) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.find((token) => token.type === 'image');
        if (imageToken) {
            const width = Number(imageToken.attrGet('width'));
            const height = Number(imageToken.attrGet('height'));
            let ratio;
            if (Number.isFinite(width) && Number.isFinite(height)) {
                ratio = height / width;
            }
            let alt = imageToken.attrGet('title') || '';
            if (!alt && imageToken.children) {
                alt = md.renderer.renderInlineAsText(imageToken.children, md.options, env);
            }
            image = {
                src: imageToken.attrGet('src'),
                alt,
                ratio,
            };
        }
    }
    const description = md.renderer.render(tokens, md.options, env);
    if (typeof metadata.storyId === 'number') {
        metadata.storyId = String(metadata.storyId);
    }
    return Object.assign(Object.assign({}, metadata), { title,
        image,
        description });
}
const changelog = function (md, { extractChangelogs, log, path }) {
    const plugin = (state) => {
        const { tokens, env } = state;
        for (let i = 0, len = tokens.length; i < len; i++) {
            const isOpen = isOpenToken(tokens, i);
            if (!isOpen)
                continue;
            const openAt = i;
            let isCloseFound = false;
            while (i < len) {
                i++;
                if (isCloseToken(tokens, i)) {
                    isCloseFound = true;
                    break;
                }
            }
            if (!isCloseFound) {
                log.error(`Changelog close tag in not found: ${(0, chalk_1.bold)(path)}`);
                break;
            }
            const closeAt = i + 2;
            if (env && extractChangelogs) {
                const content = tokens.slice(openAt, closeAt + 1);
                // cut open
                content.splice(0, 3);
                // cut close
                content.splice(-3);
                try {
                    const changelogLocal = parseBody(content, state);
                    if (!env.changelogs) {
                        env.changelogs = [];
                    }
                    env.changelogs.push(changelogLocal);
                }
                catch (err) {
                    log.error(`Changelog error: ${err.message} in ${(0, chalk_1.bold)(path)}`);
                    continue;
                }
            }
            tokens.splice(openAt, closeAt + 1 - openAt);
            len = tokens.length;
            i = openAt - 1;
        }
    };
    try {
        md.core.ruler.before('curly_attributes', 'changelog', plugin);
    }
    catch (e) {
        md.core.ruler.push('changelog', plugin);
    }
};
module.exports = changelog;
//# sourceMappingURL=index.js.map