"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const url_1 = __importDefault(require("url"));
const chalk_1 = require("chalk");
const path_1 = __importStar(require("path"));
const utils_1 = require("../../utils");
const utilsFS_1 = require("../../utilsFS");
function getTitleFromTokens(tokens) {
    let title = '';
    let i = 0;
    while (i < tokens.length) {
        const token = tokens[i];
        if (token.type === 'heading_open') {
            ({ title = '' } = (0, utils_1.headingInfo)(tokens, i));
            break;
        }
        i += 2;
    }
    return title;
}
const getTitle = (id, options) => {
    const { file, state, opts } = options;
    const fileTokens = (0, utilsFS_1.getFileTokens)(file, state, Object.assign(Object.assign({}, opts), { disableLint: true, disableTitleRefSubstitution: true, disableCircularError: true, inheritVars: false }));
    const sourceTokens = id ? (0, utils_1.findBlockTokens)(fileTokens, id) : fileTokens;
    return getTitleFromTokens(sourceTokens);
};
const addTitle = (options) => {
    var _a;
    const { hash, state, isEmptyLink, tokens, idx, nextToken, href, currentPath, log, cache } = options;
    const id = hash && hash.slice(1);
    const key = [id, path_1.default].join('::');
    const title = (_a = cache === null || cache === void 0 ? void 0 : cache.get(key)) !== null && _a !== void 0 ? _a : getTitle(id, options);
    cache === null || cache === void 0 ? void 0 : cache.set(key, title);
    if (title) {
        let textToken;
        if (isEmptyLink) {
            textToken = new state.Token('text', '', 0);
            tokens.splice(idx + 1, 0, textToken);
        }
        else {
            textToken = nextToken;
        }
        textToken.content = title;
    }
    else {
        log.warn(`Title not found: ${(0, chalk_1.bold)(href)} in ${(0, chalk_1.bold)(currentPath)}`);
    }
};
function getDefaultPublicPath({ file, path, }, input) {
    return (0, path_1.relative)((0, path_1.parse)(path || '').dir, input || file || '');
}
// eslint-disable-next-line complexity
function processLink(state, tokens, idx, opts) {
    const { path: startPath, root, transformLink, notFoundCb, needSkipLinkFn, log, getPublicPath = getDefaultPublicPath, cache, } = opts;
    const currentPath = state.env.path || startPath;
    const linkToken = tokens[idx];
    const nextToken = tokens[idx + 1];
    let href = (0, utils_1.getHrefTokenAttr)(linkToken);
    if (!href) {
        log.error(`Empty link in ${(0, chalk_1.bold)(startPath)}`);
        return;
    }
    const { pathname, hash } = url_1.default.parse(href);
    let file;
    let fileExists;
    let isPageFile;
    if (!(0, utils_1.isLocalUrl)(href)) {
        linkToken.attrSet('target', '_blank');
        linkToken.attrSet('rel', 'noreferrer noopener');
        return;
    }
    if (pathname) {
        file = (0, path_1.resolve)(path_1.default.parse(currentPath).dir, pathname);
        fileExists = (0, utilsFS_1.isFileExists)(file);
        isPageFile = utils_1.PAGE_LINK_REGEXP.test(pathname);
        if (isPageFile && !fileExists) {
            let needShowError = true;
            if (needSkipLinkFn) {
                needShowError = !needSkipLinkFn(href);
            }
            if (notFoundCb && needShowError) {
                notFoundCb(file.replace(root, ''));
            }
            if (needShowError) {
                log.error(`Link is unreachable: ${(0, chalk_1.bold)(href)} in ${(0, chalk_1.bold)(currentPath)}`);
            }
        }
    }
    else if (hash) {
        file = startPath;
        fileExists = true;
        isPageFile = true;
    }
    else {
        return;
    }
    const isEmptyLink = nextToken.type === 'link_close';
    const isTitleRefLink = nextToken.type === 'text' && nextToken.content === '{#T}';
    if ((isEmptyLink || isTitleRefLink) &&
        fileExists &&
        isPageFile &&
        !state.env.disableTitleRefSubstitution) {
        addTitle({
            hash,
            file,
            state,
            opts,
            isEmptyLink,
            tokens,
            idx,
            nextToken,
            href,
            currentPath,
            log,
            cache,
        });
    }
    let newPathname = '';
    if (!(0, path_1.isAbsolute)(href) && !href.includes('//')) {
        newPathname = getPublicPath(opts, file);
        href = url_1.default.format(Object.assign(Object.assign({}, url_1.default.parse(href)), { pathname: newPathname }));
    }
    if (pathname || newPathname) {
        const transformer = transformLink || utils_1.defaultTransformLink;
        linkToken.attrSet('href', transformer(href));
    }
}
const index = (md, opts) => {
    const plugin = (state) => {
        const tokens = state.tokens;
        let i = 0;
        while (i < tokens.length) {
            if (tokens[i].type === 'inline') {
                const childrenTokens = tokens[i].children || [];
                let j = 0;
                while (j < childrenTokens.length) {
                    const isLinkOpenToken = childrenTokens[j].type === 'link_open';
                    const tokenClass = childrenTokens[j].attrGet('class');
                    /*  Don't process anchor links */
                    const isYfmAnchor = tokenClass ? tokenClass.includes('yfm-anchor') : false;
                    if (isLinkOpenToken && !isYfmAnchor) {
                        processLink(state, childrenTokens, j, opts);
                    }
                    j++;
                }
            }
            i++;
        }
    };
    try {
        md.core.ruler.before('includes', 'links', plugin);
    }
    catch (e) {
        md.core.ruler.push('links', plugin);
    }
};
module.exports = index;
//# sourceMappingURL=index.js.map