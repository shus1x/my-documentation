{
  "version": 3,
  "sources": ["../../src/plugin/index.ts", "../../src/plugin/plugin.ts", "../../src/plugin/const.ts", "../../src/plugin/helpers.ts", "../../src/plugin/utils.ts", "../../src/plugin/transform.ts"],
  "sourcesContent": ["export type {TransformOptions} from './transform';\nexport {transform} from './transform';\nexport {TokenType} from './const';\n", "import type MarkdownIt from 'markdown-it';\nimport type Core from 'markdown-it/lib/parser_core';\n\nimport {AttrsParser} from '@diplodoc/utils';\n\nimport {ClassNames, ENV_FLAG_NAME, TokenType} from './const';\nimport {findCloseTokenIdx, matchOpenToken} from './helpers';\n\nexport const cutPlugin: MarkdownIt.PluginSimple = (md) => {\n    const rule: Core.RuleCore = (state) => {\n        const tokens = state.tokens;\n        let i = 0;\n\n        while (i < tokens.length) {\n            const match = matchOpenToken(tokens, i);\n\n            if (match) {\n                const closeTokenIdx = findCloseTokenIdx(tokens, i + 4);\n\n                if (!closeTokenIdx) {\n                    i += 3;\n                    continue;\n                }\n\n                const title = match[1];\n                const attrs = match[2] || '';\n\n                if (typeof title === 'undefined') {\n                    throw new Error(`No title provided for cut ${match[0]}`);\n                }\n\n                const attrsParser = new AttrsParser(attrs);\n\n                const newOpenToken = new state.Token(TokenType.CutOpen, 'details', 1);\n                newOpenToken.attrSet('class', ClassNames.Cut);\n                newOpenToken.map = tokens[i].map;\n\n                attrsParser.apply(newOpenToken);\n\n                const titleOpen = new state.Token(TokenType.TitleOpen, 'summary', 1);\n                titleOpen.attrSet('class', ClassNames.Title);\n\n                const titleInline = state.md.parseInline(title, state.env)[0];\n\n                const titleClose = new state.Token(TokenType.TitleClose, 'summary', -1);\n\n                const contentOpen = new state.Token(TokenType.ContentOpen, 'div', 1);\n                contentOpen.attrSet('class', ClassNames.Content);\n\n                if (newOpenToken.map) {\n                    const contentOpenStart = newOpenToken.map[0] + 1;\n                    const contentOpenEnd = newOpenToken.map[0] + 2;\n\n                    contentOpen.map = [contentOpenStart, contentOpenEnd];\n                }\n\n                const contentClose = new state.Token(TokenType.ContentClose, 'div', -1);\n\n                const newCloseToken = new state.Token(TokenType.CutClose, 'details', -1);\n                newCloseToken.map = tokens[closeTokenIdx].map;\n\n                const insideTokens = [\n                    newOpenToken,\n                    titleOpen,\n                    titleInline,\n                    titleClose,\n                    contentOpen,\n                    ...tokens.slice(i + 3, closeTokenIdx),\n                    contentClose,\n                    newCloseToken,\n                ];\n\n                tokens.splice(i, closeTokenIdx - i + 3, ...insideTokens);\n\n                state.env ??= {};\n                state.env[ENV_FLAG_NAME] = true;\n\n                i++;\n            } else {\n                i++;\n            }\n        }\n    };\n\n    try {\n        md.core.ruler.before('curly_attributes', 'cut', rule);\n    } catch (e) {\n        md.core.ruler.push('cut', rule);\n    }\n};\n", "export const ENV_FLAG_NAME = 'has-yfm-cut';\n\nexport const TokenType = {\n    Cut: 'yfm_cut',\n    CutOpen: 'yfm_cut_open',\n    CutClose: 'yfm_cut_close',\n    Title: 'yfm_cut_title',\n    TitleOpen: 'yfm_cut_title_open',\n    TitleClose: 'yfm_cut_title_close',\n    Content: 'yfm_cut_content',\n    ContentOpen: 'yfm_cut_content_open',\n    ContentClose: 'yfm_cut_content_close',\n} as const;\n\nexport const ClassNames = {\n    Cut: 'yfm-cut',\n    Title: 'yfm-cut-title',\n    Content: 'yfm-cut-content',\n} as const;\n", "import type MdIt from 'markdown-it';\n\nconst CUT_REGEXP = /^{%\\s*cut\\s*[\"|'](.*)[\"|']\\s*%}(.*)?$/;\n\nexport function matchOpenToken(tokens: MdIt.Token[], i: number) {\n    return (\n        tokens[i].type === 'paragraph_open' &&\n        tokens[i + 1].type === 'inline' &&\n        tokens[i + 1].content.match(CUT_REGEXP)\n    );\n}\n\nexport function matchCloseToken(tokens: MdIt.Token[], i: number) {\n    return (\n        tokens[i].type === 'paragraph_open' &&\n        tokens[i + 1].type === 'inline' &&\n        tokens[i + 1].content.trim() === '{% endcut %}'\n    );\n}\n\nexport function findCloseTokenIdx(tokens: MdIt.Token[], idx: number) {\n    let level = 0;\n    let i = idx;\n    while (i < tokens.length) {\n        if (matchOpenToken(tokens, i)) {\n            level++;\n        } else if (matchCloseToken(tokens, i)) {\n            if (level === 0) {\n                return i;\n            }\n            level--;\n        }\n\n        i++;\n    }\n\n    return null;\n}\n", "export function hidden<B extends Record<string | symbol, unknown>, F extends string | symbol, V>(\n    box: B,\n    field: F,\n    value: V,\n) {\n    if (!(field in box)) {\n        Object.defineProperty(box, field, {\n            enumerable: false,\n            value: value,\n        });\n    }\n\n    return box as B & {[P in F]: V};\n}\n\nexport type Runtime = {\n    script: string;\n    style: string;\n};\n\ndeclare const __dirname: string;\nexport function copyRuntime(\n    {runtime, output}: {runtime: Runtime; output: string},\n    cache: Set<string>,\n) {\n    const PATH_TO_RUNTIME = '../runtime';\n    const {join, resolve} = dynrequire('node:path');\n    const runtimeFiles = {\n        'index.js': runtime.script,\n        'index.css': runtime.style,\n    };\n    for (const [originFile, outputFile] of Object.entries(runtimeFiles)) {\n        const file = join(PATH_TO_RUNTIME, originFile);\n        if (!cache.has(file)) {\n            cache.add(file);\n            copy(resolve(__dirname, file), join(output, outputFile));\n        }\n    }\n}\n\nexport function copy(from: string, to: string) {\n    const {mkdirSync, copyFileSync} = dynrequire('node:fs');\n    const {dirname} = dynrequire('node:path');\n\n    mkdirSync(dirname(to), {recursive: true});\n    copyFileSync(from, to);\n}\n\n/*\n * Runtime require hidden for builders.\n * Used for nodejs api\n */\nexport function dynrequire(module: string) {\n    // eslint-disable-next-line no-eval\n    return eval(`require('${module}')`);\n}\n", "import type MarkdownIt from 'markdown-it';\n\nimport {cutPlugin} from './plugin';\nimport {type Runtime, copyRuntime, dynrequire, hidden} from './utils';\nimport {ENV_FLAG_NAME} from './const';\n\nexport type TransformOptions = {\n    runtime?:\n        | string\n        | {\n              script: string;\n              style: string;\n          };\n    bundle?: boolean;\n};\n\ntype NormalizedPluginOptions = Omit<TransformOptions, 'runtime'> & {\n    runtime: Runtime;\n};\n\nconst registerTransform = (\n    md: MarkdownIt,\n    {\n        runtime,\n        bundle,\n        output,\n    }: Pick<NormalizedPluginOptions, 'bundle' | 'runtime'> & {\n        output: string;\n    },\n) => {\n    md.use(cutPlugin);\n    md.core.ruler.push('yfm_cut_after', ({env}) => {\n        hidden(env, 'bundled', new Set<string>());\n\n        if (env?.[ENV_FLAG_NAME]) {\n            env.meta = env.meta || {};\n            env.meta.script = env.meta.script || [];\n            env.meta.script.push(runtime.script);\n            env.meta.style = env.meta.style || [];\n            env.meta.style.push(runtime.style);\n\n            if (bundle) {\n                copyRuntime({runtime, output}, env.bundled);\n            }\n        }\n    });\n};\n\ntype InputOptions = {\n    destRoot: string;\n};\n\nexport function transform(options: Partial<TransformOptions> = {}) {\n    const {bundle = true} = options;\n\n    if (bundle && typeof options.runtime === 'string') {\n        throw new TypeError('Option `runtime` should be record when `bundle` is enabled.');\n    }\n\n    const runtime: Runtime =\n        typeof options.runtime === 'string'\n            ? {script: options.runtime, style: options.runtime}\n            : options.runtime || {\n                  script: '_assets/cut-extension.js',\n                  style: '_assets/cut-extension.css',\n              };\n\n    const plugin: MarkdownIt.PluginWithOptions<{output?: string}> = function (\n        md: MarkdownIt,\n        {output = '.'} = {},\n    ) {\n        registerTransform(md, {\n            runtime,\n            bundle,\n            output,\n        });\n    };\n\n    Object.assign(plugin, {\n        collect(input: string, {destRoot = '.'}: InputOptions) {\n            const MdIt = dynrequire('markdown-it');\n            const md = new MdIt().use((md: MarkdownIt) => {\n                registerTransform(md, {\n                    runtime,\n                    bundle,\n                    output: destRoot,\n                });\n            });\n\n            md.parse(input, {});\n        },\n    });\n\n    return plugin;\n}\n"],
  "mappings": "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",
  "names": ["md"]
}
