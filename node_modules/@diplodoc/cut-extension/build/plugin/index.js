"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/plugin/index.ts
var plugin_exports = {};
__export(plugin_exports, {
  TokenType: () => TokenType,
  transform: () => transform
});
module.exports = __toCommonJS(plugin_exports);

// src/plugin/plugin.ts
var import_utils = require("@diplodoc/utils");

// src/plugin/const.ts
var ENV_FLAG_NAME = "has-yfm-cut";
var TokenType = {
  Cut: "yfm_cut",
  CutOpen: "yfm_cut_open",
  CutClose: "yfm_cut_close",
  Title: "yfm_cut_title",
  TitleOpen: "yfm_cut_title_open",
  TitleClose: "yfm_cut_title_close",
  Content: "yfm_cut_content",
  ContentOpen: "yfm_cut_content_open",
  ContentClose: "yfm_cut_content_close"
};
var ClassNames = {
  Cut: "yfm-cut",
  Title: "yfm-cut-title",
  Content: "yfm-cut-content"
};

// src/plugin/helpers.ts
var CUT_REGEXP = /^{%\s*cut\s*["|'](.*)["|']\s*%}(.*)?$/;
function matchOpenToken(tokens, i) {
  return tokens[i].type === "paragraph_open" && tokens[i + 1].type === "inline" && tokens[i + 1].content.match(CUT_REGEXP);
}
function matchCloseToken(tokens, i) {
  return tokens[i].type === "paragraph_open" && tokens[i + 1].type === "inline" && tokens[i + 1].content.trim() === "{% endcut %}";
}
function findCloseTokenIdx(tokens, idx) {
  let level = 0;
  let i = idx;
  while (i < tokens.length) {
    if (matchOpenToken(tokens, i)) {
      level++;
    } else if (matchCloseToken(tokens, i)) {
      if (level === 0) {
        return i;
      }
      level--;
    }
    i++;
  }
  return null;
}

// src/plugin/plugin.ts
var cutPlugin = (md) => {
  const rule = (state) => {
    const tokens = state.tokens;
    let i = 0;
    while (i < tokens.length) {
      const match = matchOpenToken(tokens, i);
      if (match) {
        const closeTokenIdx = findCloseTokenIdx(tokens, i + 4);
        if (!closeTokenIdx) {
          i += 3;
          continue;
        }
        const title = match[1];
        const attrs = match[2] || "";
        if (typeof title === "undefined") {
          throw new Error(`No title provided for cut ${match[0]}`);
        }
        const attrsParser = new import_utils.AttrsParser(attrs);
        const newOpenToken = new state.Token(TokenType.CutOpen, "details", 1);
        newOpenToken.attrSet("class", ClassNames.Cut);
        newOpenToken.map = tokens[i].map;
        attrsParser.apply(newOpenToken);
        const titleOpen = new state.Token(TokenType.TitleOpen, "summary", 1);
        titleOpen.attrSet("class", ClassNames.Title);
        const titleInline = state.md.parseInline(title, state.env)[0];
        const titleClose = new state.Token(TokenType.TitleClose, "summary", -1);
        const contentOpen = new state.Token(TokenType.ContentOpen, "div", 1);
        contentOpen.attrSet("class", ClassNames.Content);
        if (newOpenToken.map) {
          const contentOpenStart = newOpenToken.map[0] + 1;
          const contentOpenEnd = newOpenToken.map[0] + 2;
          contentOpen.map = [contentOpenStart, contentOpenEnd];
        }
        const contentClose = new state.Token(TokenType.ContentClose, "div", -1);
        const newCloseToken = new state.Token(TokenType.CutClose, "details", -1);
        newCloseToken.map = tokens[closeTokenIdx].map;
        const insideTokens = [
          newOpenToken,
          titleOpen,
          titleInline,
          titleClose,
          contentOpen,
          ...tokens.slice(i + 3, closeTokenIdx),
          contentClose,
          newCloseToken
        ];
        tokens.splice(i, closeTokenIdx - i + 3, ...insideTokens);
        state.env ??= {};
        state.env[ENV_FLAG_NAME] = true;
        i++;
      } else {
        i++;
      }
    }
  };
  try {
    md.core.ruler.before("curly_attributes", "cut", rule);
  } catch (e) {
    md.core.ruler.push("cut", rule);
  }
};

// src/plugin/utils.ts
function hidden(box, field, value) {
  if (!(field in box)) {
    Object.defineProperty(box, field, {
      enumerable: false,
      value
    });
  }
  return box;
}
function copyRuntime({ runtime, output }, cache) {
  const PATH_TO_RUNTIME = "../runtime";
  const { join, resolve } = dynrequire("node:path");
  const runtimeFiles = {
    "index.js": runtime.script,
    "index.css": runtime.style
  };
  for (const [originFile, outputFile] of Object.entries(runtimeFiles)) {
    const file = join(PATH_TO_RUNTIME, originFile);
    if (!cache.has(file)) {
      cache.add(file);
      copy(resolve(__dirname, file), join(output, outputFile));
    }
  }
}
function copy(from, to) {
  const { mkdirSync, copyFileSync } = dynrequire("node:fs");
  const { dirname } = dynrequire("node:path");
  mkdirSync(dirname(to), { recursive: true });
  copyFileSync(from, to);
}
function dynrequire(module) {
  return eval(`require('${module}')`);
}

// src/plugin/transform.ts
var registerTransform = (md, {
  runtime,
  bundle,
  output
}) => {
  md.use(cutPlugin);
  md.core.ruler.push("yfm_cut_after", ({ env }) => {
    hidden(env, "bundled", /* @__PURE__ */ new Set());
    if (env?.[ENV_FLAG_NAME]) {
      env.meta = env.meta || {};
      env.meta.script = env.meta.script || [];
      env.meta.script.push(runtime.script);
      env.meta.style = env.meta.style || [];
      env.meta.style.push(runtime.style);
      if (bundle) {
        copyRuntime({ runtime, output }, env.bundled);
      }
    }
  });
};
function transform(options = {}) {
  const { bundle = true } = options;
  if (bundle && typeof options.runtime === "string") {
    throw new TypeError("Option `runtime` should be record when `bundle` is enabled.");
  }
  const runtime = typeof options.runtime === "string" ? { script: options.runtime, style: options.runtime } : options.runtime || {
    script: "_assets/cut-extension.js",
    style: "_assets/cut-extension.css"
  };
  const plugin = function(md, { output = "." } = {}) {
    registerTransform(md, {
      runtime,
      bundle,
      output
    });
  };
  Object.assign(plugin, {
    collect(input, { destRoot = "." }) {
      const MdIt = dynrequire("markdown-it");
      const md = new MdIt().use((md2) => {
        registerTransform(md2, {
          runtime,
          bundle,
          output: destRoot
        });
      });
      md.parse(input, {});
    }
  });
  return plugin;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TokenType,
  transform
});
//# sourceMappingURL=index.js.map
